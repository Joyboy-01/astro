---
title: lambda学习记录
publishDate: 2025-07-8 15:29:00
description: 'lambda学习记录'
tags:
  - 记录
# heroImage: { src: './pic.png', color: '#B4C6DA' }
language: '中文'
---

lambda演算由Alonzo Church提出，后成为计算机领域的基石。最近在做类型推断的过程中接触到
这里记录一些我花了一些时间理解的内容，参考[此blog](https://juejin.cn/post/7238917665851146296)

## 基础运算

Lambda 演算由三种元素组成: **变量**(variables)、**函数**(functions)和**应用**(applications)。
对于函数 `λx.x`我们就可以直接把`.`前的作为函数参数，后面的作为函数体就可以了。参数也可以传入函数，church数就是这样子定义的，如`λf.λx.f x`。

对于思考：假设m和n都是邱奇数，那么(m n)是哪种运算。
答案是幂运算。对于定义`λf.λx.fⁿ x`来说我们知道了后继函数`S = λn.λf.λx.f((n f) x)`,也就是`fⁿ`被表达为了`(n f)`，所以代表的是exp函数

## Church pair

在提出church数减法的的时候引入。由于lambda演算的特性之一是没有能储存数据的数组之类的东西，所以churchpair被用于储存。对于：

$$
\text{pair} = \lambda x.\lambda y.\lambda s.(s\,x\,y)
$$

我们理解为当我们输入x，y两变量，church对自动保存两变量（并返回$\lambda s.(s\,x\,y)$），当输入s的时候立即计算。
如文中给的例子取两个变量中的第一个：

$$
\text{first} = \lambda p.(p\,\lambda x.\lambda y.x)
$$

我们输入为church pair: pair a b，即$\lambda s.(s\,a\,b)$，运算为：

$$
(\lambda s.s\,a\,b)\,(\lambda x.\lambda y.x) = \lambda x.\lambda y.x\,(a\,b) = a
$$

## IF

以`IsZERO`为例子：

$$
\text{isZero} = \lambda n.(n\,(\lambda a.\text{FALSE})\,\text{TRUE})
$$

对于推断：

$$
\text{isZero ONE} = \lambda n.(n\,(\lambda a.\text{FALSE})\,\text{TRUE})\,(\lambda f.\lambda x.(f\,x))
$$

代入后可以发现f这个变量对应的是$\lambda n.(n\,(\lambda a.\text{FALSE})\,\text{TRUE})$，所以只要f存在，就是假，这对于church数来说是正确的。

## Y combinator 与不动点

对应了另一个lambda演算的特性：没有函数名字。如果递归没有函数名字我们就不能像现代语言一样处理递归。

```javascript
let fact = (n) => {
    if (n == 0) return 1;
    else return n * fact(n - 1);
};
```

我们需要先定义一个"模板"函数 `F`。这个 `F`多了一个参数 `g`，这个 `g`就代表了我们最终想要的递归函数本身。

```javascript
let F = (g) => {
    return (n) => {
        if (n == 0) return 1;
        else return n * g(n - 1);
    };
};
```

我们要找到函数Y使得`Y(F) = fact`，可以发现`fact(n) = F(fact)(n)`，不动点在函数上表示为：

$$
Y(f) = f
$$

f可以是函数或者变量。所以fact函数为F的一个不动点，我们的目标是找到一个通用的方法，对于任意的 `F`，都能计算出它的不动点 `X`，使得 `X = F(X)`。

可以构造出自应用模型：

$$
\lambda X.(X\,X)
$$

（也称作β归约的不动点），然后包一层F构造出函数：

$$
G = \lambda X.(F\,(X\,X))
$$

这个函数的意义在于：当我们将某个函数 `X`应用到自己身上时（即 `(X X)`），其结果会被外层的函数 `F`所处理。于是：

$$
G(G) = F\,(G\,G)
$$

发现G(G)就是不动点。代入：

$$
(\lambda X.(F\,(X\,X)))\,(\lambda X.(F\,(X\,X))) = F((\lambda X.(F\,(X\,X)))\,(\lambda X.(F\,(X\,X))))
$$

验证使得$X = F(X)$，所以：

$$
Y = \lambda F.(\lambda x.(F\,(x\,x)))\,(\lambda x.(F\,(x\,x)))
$$

每输入一个F就能返回他的不动点，也就是递归函数。

[Y组合子的一个启发式推导](https://zhuanlan.zhihu.com/p/547191928)这里有启发式的推导得到Y组合子。

## 判定相等

**图灵机停机问题**：是否存在一个通用算法，能够预先判断任意一个程序在给定输入下，是否能在有限时间内结束运行（停机），还是会永远运行下去（无法停机）。图灵已经证明这种算法不存在，这标志存在一些问题，是无论计算机多么强大，在理论上都无法通过算法解决的。

还有一些规则和定理如转换与归约规则，Church-Rosser定理，在原博客已经讲的很详细了

## 组合子

使组合子逻辑变得有意义的是，一些数学家发现，仅通过一组特定的组合子，我们就可以无需定义新的lambda函数，达成图灵完备。然而在lambda推断增加了类型之后因为无法构造不动点，不能产生递归类型，不是图灵完备的，组合子也无法构造。

### ISK组合子的意义

| 组合子 | Lambda 表达式 | 行为规则 | 核心意义 |
| --------------- | ---------------------- | ---------------------- | ---------------------------------------------------------------- |
| **I（恒等子）** | $\lambda x.x$ | `I x => x` | **保持不变**。输出就是输入。 |
| **K（常量子）** | $\lambda x.\lambda y.x$ | `K x y => x` | **丢弃第二个参数，保留第一个**。用于创建常量函数。 |
| **S（强组合子）** | $\lambda x.\lambda y.\lambda z.x\,z\,(y\,z)$ | `S x y z => x z (y z)` | **分发参数**。将参数 `z`同时传递给函数 `x`和 `y`，然后将结果进行应用。这是实现函数复用和参数传递的关键。 |

## Curry-Howard

为了解决Kleene-Rosser悖论，邱奇提出了为lambda函数引入类型，这使lambda演算失去了图灵完备性，然而即使失去了图灵完备性，简单类型lambda演算也拥有巨大的潜力。由 Haskell Curry 提出，并由 Howard 发展的 Curry-Howard 同构，揭示了简单类型论与命题逻辑之间的深刻联系。

- 证明一个定理等价于编写一个具有特定类型的程序。
- 证明的构造过程等价于程序的编写过程。
- 证明的正确性检查等价于程序的类型检查。

这让我想到了jyy老师常说的"程序是数学严格的"

以下引用自claude

Curry-Howard同构在现代类型系统和语义分析研究中至关重要，主要体现在以下几个方面：

- 首先，它为类型系统提供了坚实的数学基础。通过建立"类型↔命题、程序↔证明"的对应关系，类型系统不再只是工程实践，而是有严格逻辑学支撑的形式化系统。这使得我们可以借用成熟的证明论和逻辑学工具来分析和设计类型系统，比如用逻辑一致性来保证类型安全性。
- 其次，它直接指导了现代类型特性的设计。代数数据类型对应逻辑的合取和析取，依赖类型对应全称和存在量化，线性类型对应线性逻辑——这些对应关系不是巧合，而是设计原则。Rust的所有权系统、Haskell的类型类、Agda的依赖类型，都深受这一理论影响。通过逻辑对应，设计者能确保新类型特性在理论上是健全和一致的。
- 第三，它为语义分析提供了统一框架。程序执行对应证明归约，这让我们可以用证明论的归一化性质来分析程序终止性，用范畴论来研究程序等价性。特别是在处理副作用时，通过扩展到模态逻辑和代数效应，我们能系统地理解和设计效应系统。
- 第四，它帮助理解类型推断的本质边界。类型推断实质上是自动定理证明，而Curry-Howard揭示了为什么Hindley-Milner是可判定的（对应命题逻辑片段），而System F不可判定（对应二阶逻辑）。这指导了实用语言在表达力和可推断性之间做出明智的权衡。
- 最后，它使"程序验证即类型检查"成为可能。在Coq、Agda等证明助手中，编写程序就是构造证明，类型就是定理。这不仅推动了形式化验证技术的发展，也启发了精化类型、液态类型等实用验证技术，让程序的正确性能在类型层面得到保证。

## 参考

[函数式编程的数学基础](https://juejin.cn/post/7238917665851146296)
[Y组合子的一个启发式推导](https://zhuanlan.zhihu.com/p/547191928)